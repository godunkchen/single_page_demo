<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPS Constellation Simulator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: sans-serif; }
        canvas { display: block; }
        .ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            pointer-events: none;
        }
        .controls {
            pointer-events: auto;
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        input, select, button {
            pointer-events: auto;
        }
        .plane-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        .plane-inactive {
            opacity: 0.3;
            text-decoration: line-through;
        }
    </style>
</head>
<body>

    <div class="ui-overlay flex flex-col gap-4 text-white">
        <div class="controls p-6 rounded-xl shadow-2xl w-80">
            <h1 class="text-xl font-bold mb-4 border-b border-white/20 pb-2 text-blue-400">GPS Constellation</h1>
            
            <div class="mb-4">
                <label class="block text-xs uppercase tracking-wider text-slate-400 mb-1">Viewpoint Preset</label>
                <select id="viewSelect" class="w-full bg-slate-800 border border-slate-600 rounded p-2 text-sm">
                    <option value="equator">Top of Equator</option>
                    <option value="inclined">Inclined (55°)</option>
                    <option value="pole">North Pole</option>
                </select>
            </div>

            <div class="mb-4">
                <label class="block text-xs uppercase tracking-wider text-slate-400 mb-1">Set Date & Time</label>
                <input type="datetime-local" id="dateInput" class="w-full bg-slate-800 border border-slate-600 rounded p-2 text-sm text-white">
            </div>

            <div class="mb-4">
                <div class="flex items-center justify-between mb-1">
                    <span class="text-xs uppercase tracking-wider text-slate-400">Time Multiplier</span>
                    <span id="speedVal" class="text-xs font-mono text-blue-300">1x</span>
                </div>
                <input type="range" id="speedInput" min="0" max="10000" value="100" class="w-full">
            </div>

            <div class="mb-2">
                <label class="block text-xs uppercase tracking-wider text-slate-400 mb-2">Toggle Planes (Keys A-F)</label>
                <div id="planeLegend" class="grid grid-cols-2 gap-2 text-xs font-mono">
                    <!-- Legend items generated by JS -->
                </div>
            </div>

            <div class="text-xs text-slate-400 border-t border-white/10 pt-4 mt-2 space-y-1">
                <p>• <b>Click & Drag:</b> Rotate View</p>
                <p>• <b>Scroll:</b> Zoom In/Out</p>
                <p>• <b>A~F Keys:</b> Toggle Orbital Planes</p>
            </div>
        </div>
        
        <div id="status" class="controls px-4 py-2 rounded-lg text-sm font-mono text-blue-200">
            Initialising Orbit Data...
        </div>
    </div>

    <script>
        // Constants
        const EARTH_RADIUS = 6.371; 
        const GPS_ALTITUDE = 20.200; 
        const ORBIT_RADIUS = EARTH_RADIUS + GPS_ALTITUDE;
        const INCLINATION = (55 * Math.PI) / 180; 
        const SIDEREAL_DAY_SECONDS = 86164;

        // Three.js State
        let scene, camera, renderer, earthGroup, stars;
        let satellites = [];
        let orbitLines = [];
        let simulationTime = new Date();
        let timeMultiplier = 1;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        // Colors for the 6 planes (A through F)
        const PLANE_COLORS = [
            0xff3333, // A: Red
            0xff9900, // B: Orange
            0x33ff33, // C: Green
            0x00ffff, // D: Cyan
            0x3366ff, // E: Blue
            0xff33ff  // F: Magenta
        ];

        const dateInput = document.getElementById('dateInput');
        const viewSelect = document.getElementById('viewSelect');
        const speedInput = document.getElementById('speedInput');
        const speedVal = document.getElementById('speedVal');
        const statusDiv = document.getElementById('status');
        const planeLegend = document.getElementById('planeLegend');

        function init() {
            const now = new Date();
            now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
            dateInput.value = now.toISOString().slice(0, 16);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
            sunLight.position.set(100, 50, 100);
            scene.add(sunLight);

            // Stars
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.15 });
            const starVertices = [];
            for (let i = 0; i < 5000; i++) {
                const x = (Math.random() - 0.5) * 1800;
                const y = (Math.random() - 0.5) * 1800;
                const z = (Math.random() - 0.5) * 1800;
                starVertices.push(x, y, z);
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);

            earthGroup = new THREE.Group();
            scene.add(earthGroup);

            // Earth
            const earthGeom = new THREE.SphereGeometry(EARTH_RADIUS, 64, 64);
            const earthMat = new THREE.MeshPhongMaterial({
                color: 0x1a3a6a,
                emissive: 0x051020,
                wireframe: true,
                transparent: true,
                opacity: 0.7
            });
            const earth = new THREE.Mesh(earthGeom, earthMat);
            earthGroup.add(earth);

            // Equator reference
            const equatorGeom = new THREE.RingGeometry(EARTH_RADIUS + 0.1, EARTH_RADIUS + 0.3, 128);
            const equatorMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0.2 });
            const equatorLine = new THREE.Mesh(equatorGeom, equatorMat);
            equatorLine.rotation.x = Math.PI / 2;
            earthGroup.add(equatorLine);

            // Create Legend & Setup Planes
            for (let p = 0; p < 6; p++) {
                const char = String.fromCharCode(65 + p); // A, B, C...
                const raan = (p * 60 * Math.PI) / 180; 
                const color = PLANE_COLORS[p];

                // Add Legend Item
                const item = document.createElement('div');
                item.id = `legend-${p}`;
                item.className = 'flex items-center cursor-pointer hover:bg-white/5 p-1 rounded transition-colors';
                item.innerHTML = `<span class="plane-dot" style="background-color: #${color.toString(16).padStart(6, '0')}"></span> [${char}] Plane ${char}`;
                item.onclick = () => togglePlane(p);
                planeLegend.appendChild(item);

                // Create Orbit Line
                const orbitCurve = new THREE.EllipseCurve(0, 0, ORBIT_RADIUS, ORBIT_RADIUS);
                const points = orbitCurve.getPoints(128);
                const orbitGeom = new THREE.BufferGeometry().setFromPoints(points);
                const orbitMat = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.6 });
                const orbitLine = new THREE.LineLoop(orbitGeom, orbitMat);
                
                orbitLine.rotation.order = 'YXZ';
                orbitLine.rotation.x = INCLINATION;
                orbitLine.rotation.y = raan;
                earthGroup.add(orbitLine);
                orbitLines.push(orbitLine);

                for (let s = 0; s < 4; s++) {
                    const anomalyOffset = (s * 90 * Math.PI) / 180 + (p * 15 * Math.PI) / 180;
                    
                    const satGeom = new THREE.SphereGeometry(0.7, 12, 12);
                    const satMat = new THREE.MeshPhongMaterial({ 
                        color: color, 
                        emissive: color,
                        emissiveIntensity: 0.8
                    });
                    const satMesh = new THREE.Mesh(satGeom, satMat);
                    
                    satellites.push({
                        mesh: satMesh,
                        raan: raan,
                        anomalyOffset: anomalyOffset,
                        planeIndex: p
                    });
                    earthGroup.add(satMesh);
                }
            }

            updateCameraPosition();
            
            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            viewSelect.addEventListener('change', updateCameraPosition);
            speedInput.addEventListener('input', (e) => {
                timeMultiplier = e.target.value;
                speedVal.innerText = timeMultiplier + 'x';
            });
            dateInput.addEventListener('input', (e) => {
                simulationTime = new Date(e.target.value);
            });

            // Keyboard Toggle
            window.addEventListener('keydown', (e) => {
                const key = e.key.toUpperCase();
                if (key >= 'A' && key <= 'F') {
                    togglePlane(key.charCodeAt(0) - 65);
                }
            });

            document.addEventListener('mousedown', (e) => { 
                if (e.target.tagName !== 'CANVAS') return;
                isDragging = true; 
                previousMousePosition = { x: e.offsetX, y: e.offsetY }; 
            });
            document.addEventListener('mouseup', (e) => { isDragging = false; });
            document.addEventListener('mousemove', handleRotation);
            document.addEventListener('wheel', (e) => {
                const factor = 1 + e.deltaY * 0.001;
                camera.position.multiplyScalar(factor);
                const dist = camera.position.length();
                if (dist < 12) camera.position.setLength(12);
                if (dist > 300) camera.position.setLength(300);
            });

            animate();
        }

        function togglePlane(index) {
            const isVisible = !orbitLines[index].visible;
            orbitLines[index].visible = isVisible;
            
            // Toggle corresponding satellites
            satellites.forEach(sat => {
                if (sat.planeIndex === index) {
                    sat.mesh.visible = isVisible;
                }
            });

            // Update Legend UI
            const legendItem = document.getElementById(`legend-${index}`);
            if (isVisible) {
                legendItem.classList.remove('plane-inactive');
            } else {
                legendItem.classList.add('plane-inactive');
            }
        }

        function updateCameraPosition() {
            const dist = 80;
            camera.up.set(0, 1, 0);
            switch(viewSelect.value) {
                case 'equator':
                    camera.position.set(dist, 0, 0);
                    break;
                case 'inclined':
                    camera.position.set(0, dist * Math.sin(INCLINATION), dist * Math.cos(INCLINATION));
                    break;
                case 'pole':
                    camera.position.set(0, dist, 0);
                    camera.up.set(0, 0, -1);
                    break;
            }
            camera.lookAt(0, 0, 0);
        }

        function handleRotation(e) {
            if (!isDragging) return;
            const deltaMove = {
                x: e.offsetX - previousMousePosition.x,
                y: e.offsetY - previousMousePosition.y
            };

            const rotationSpeed = 0.006;
            const deltaRotationQuaternion = new THREE.Quaternion()
                .setFromEuler(new THREE.Euler(
                    deltaMove.y * rotationSpeed,
                    deltaMove.x * rotationSpeed,
                    0,
                    'XYZ'
                ));

            earthGroup.quaternion.multiplyQuaternions(deltaRotationQuaternion, earthGroup.quaternion);
            previousMousePosition = { x: e.offsetX, y: e.offsetY };
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateSatellites() {
            const totalSeconds = simulationTime.getTime() / 1000;
            const orbitalPeriod = SIDEREAL_DAY_SECONDS / 2; 
            
            satellites.forEach(sat => {
                const meanAnomaly = ((totalSeconds % orbitalPeriod) / orbitalPeriod) * Math.PI * 2 + sat.anomalyOffset;
                
                const pos = new THREE.Vector3(
                    ORBIT_RADIUS * Math.cos(meanAnomaly),
                    ORBIT_RADIUS * Math.sin(meanAnomaly),
                    0
                );
                
                pos.applyAxisAngle(new THREE.Vector3(1, 0, 0), INCLINATION);
                pos.applyAxisAngle(new THREE.Vector3(0, 1, 0), sat.raan);

                sat.mesh.position.copy(pos);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const deltaSeconds = (1 / 60) * timeMultiplier;
            simulationTime.setSeconds(simulationTime.getSeconds() + deltaSeconds);
            statusDiv.innerText = simulationTime.toUTCString();

            updateSatellites();
            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>
</html>